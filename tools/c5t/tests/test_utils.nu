# Tests for utils.nu - validation functions

use std/assert
use mocks.nu *

# NOTE: generate-id tests removed - IDs now auto-generated by SQLite INTEGER PRIMARY KEY

# Test get-git-status in git repo
export def "test get-git-status in git repo" [] {
  use mocks.nu git
  use ../utils.nu get-git-status

  # Mock git commands
  $env.MOCK_git_rev_parse___git_dir = ({exit_code: 0 output: ".git"} | to json)
  $env.MOCK_git_branch___show_current = ({exit_code: 0 output: "feature/test-branch"} | to json)
  $env.MOCK_git_status___porcelain = ({exit_code: 0 output: ""} | to json)
  $env.MOCK_git_log__3___oneline___no_decorate = ({exit_code: 0 output: "abc1234 Test commit\ndef5678 Another commit"} | to json)

  let result = get-git-status

  # Should return a list
  assert (($result | describe) =~ "list")

  # Should mention branch
  let text = $result | str join " "
  assert ($text | str contains "feature/test-branch")

  # Should show clean status
  assert ($text | str contains "Clean")

  # Should show commits
  assert ($text | str contains "abc1234")
}

# Test get-git-status outside git repo
export def "test get-git-status outside git repo" [] {
  use mocks.nu git
  use ../utils.nu get-git-status

  # Mock git to return non-repo (exit code 128)
  $env.MOCK_git_rev_parse___git_dir = ({exit_code: 128 output: "not a git repository"} | to json)

  let result = get-git-status

  # Should return "not a git repository" message
  assert ($result.0 | str contains "Not a git repository")
}

# Test validate-list-input accepts valid input
export def "test validate-list-input with valid input" [] {
  use ../utils.nu validate-list-input

  let args = {name: "Test List" description: "A test" tags: ["test"]}
  let result = validate-list-input $args

  assert $result.valid
}

# Test validate-list-input rejects missing name
export def "test validate-list-input rejects missing name" [] {
  use ../utils.nu validate-list-input

  let args = {description: "No name"}
  let result = validate-list-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "name")
}

# Test validate-list-input rejects empty name
export def "test validate-list-input rejects empty name" [] {
  use ../utils.nu validate-list-input

  let args = {name: "  " description: "Empty name"}
  let result = validate-list-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "empty")
}

# Test validate-item-input accepts valid input
export def "test validate-item-input with valid input" [] {
  use ../utils.nu validate-item-input

  let args = {list_id: "123" content: "Test item"}
  let result = validate-item-input $args

  assert $result.valid
}

# Test validate-item-input rejects missing list_id
export def "test validate-item-input rejects missing list_id" [] {
  use ../utils.nu validate-item-input

  let args = {content: "No list_id"}
  let result = validate-item-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "list_id")
}

# Test validate-item-input rejects missing content
export def "test validate-item-input rejects missing content" [] {
  use ../utils.nu validate-item-input

  let args = {list_id: "123"}
  let result = validate-item-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "content")
}

# Test validate-item-input rejects empty content
export def "test validate-item-input rejects empty content" [] {
  use ../utils.nu validate-item-input

  let args = {list_id: "123" content: "   "}
  let result = validate-item-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "empty")
}

# Test validate-note-input accepts valid input
export def "test validate-note-input with valid input" [] {
  use ../utils.nu validate-note-input

  let args = {title: "Test Note" content: "Note content"}
  let result = validate-note-input $args

  assert $result.valid
}

# Test validate-note-input rejects missing title
export def "test validate-note-input rejects missing title" [] {
  use ../utils.nu validate-note-input

  let args = {content: "No title"}
  let result = validate-note-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "title")
}

# Test validate-note-input rejects missing content
export def "test validate-note-input rejects missing content" [] {
  use ../utils.nu validate-note-input

  let args = {title: "No content"}
  let result = validate-note-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "content")
}

# Test validate-note-input rejects empty title
export def "test validate-note-input rejects empty title" [] {
  use ../utils.nu validate-note-input

  let args = {title: "  " content: "Empty title"}
  let result = validate-note-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "empty")
}

# Test validate-note-input rejects empty content
export def "test validate-note-input rejects empty content" [] {
  use ../utils.nu validate-note-input

  let args = {title: "Title" content: "   "}
  let result = validate-note-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "empty")
}

# Test validate-status accepts valid statuses
export def "test validate-status accepts all valid statuses" [] {
  use ../utils.nu validate-status

  let valid_statuses = ["backlog" "todo" "in_progress" "review" "done" "cancelled"]

  for status in $valid_statuses {
    let result = validate-status $status
    assert $result.valid
  }
}

# Test validate-status rejects invalid status
export def "test validate-status rejects invalid status" [] {
  use ../utils.nu validate-status

  let result = validate-status "invalid_status"

  assert (not $result.valid)
  assert ($result.error | str contains "Invalid status")
}

# Test validate-priority accepts 1-5
export def "test validate-priority accepts 1 through 5" [] {
  use ../utils.nu validate-priority

  for priority in 1..5 {
    let result = validate-priority $priority
    assert $result.valid
  }
}

# Test validate-priority rejects 0
export def "test validate-priority rejects 0" [] {
  use ../utils.nu validate-priority

  let result = validate-priority 0

  assert (not $result.valid)
  assert ($result.error | str contains "Invalid priority")
}

# Test validate-priority rejects 6
export def "test validate-priority rejects 6" [] {
  use ../utils.nu validate-priority

  let result = validate-priority 6

  assert (not $result.valid)
  assert ($result.error | str contains "Invalid priority")
}

# Test validate-priority rejects negative
export def "test validate-priority rejects negative" [] {
  use ../utils.nu validate-priority

  let result = validate-priority -1

  assert (not $result.valid)
  assert ($result.error | str contains "Invalid priority")
}

# Test validate-item-update-input accepts valid input
export def "test validate-item-update-input accepts valid input" [] {
  use ../utils.nu validate-item-update-input

  let args = {list_id: "123" item_id: "456"}
  let result = validate-item-update-input $args

  assert $result.valid
}

# Test validate-item-update-input rejects missing list_id
export def "test validate-item-update-input rejects missing list_id" [] {
  use ../utils.nu validate-item-update-input

  let args = {item_id: "456"}
  let result = validate-item-update-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "list_id")
}

# Test validate-item-update-input rejects missing item_id
export def "test validate-item-update-input rejects missing item_id" [] {
  use ../utils.nu validate-item-update-input

  let args = {list_id: "123"}
  let result = validate-item-update-input $args

  assert (not $result.valid)
  assert ($result.error | str contains "item_id")
}

# Test auto-update-scratchpad preserves LLM context with proper mocks
export def "test auto-update-scratchpad generates and updates scratchpad" [] {
  use ../utils.nu auto-update-scratchpad
  use mocks.nu *

  # Mock all database queries
  let existing_scratchpad = [
    {
      id: 1
      title: "Scratchpad"
      content: "## Active Work\n\nOld data\n\n## Key Learnings & Context\n\nMy custom context\n- Important insight"
      tags: ""
      note_type: "scratchpad"
      created_at: "2025-01-01"
      updated_at: "2025-01-01"
    }
  ]

  with-env {
    # Mock get-scratchpad (first query returns existing)
    MOCK_query_db: {output: $existing_scratchpad exit_code: 0}
    # Mock get-active-lists-with-counts
    MOCK_query_db_TODO_LIST: {output: [] exit_code: 0}
    # Mock get-all-in-progress-items, get-recently-completed-items, get-high-priority-next-steps
    MOCK_query_db_EMPTY_ITEMS: true
    # Mock update-scratchpad (UPDATE query)
    MOCK_query_db_CHECK_SCRATCHPAD: {output: [{id: 1}] exit_code: 0}
    MOCK_query_db_UPDATE: {output: [] exit_code: 0}
    # Mock git
    MOCK_git_rev_parse___git_dir: ({exit_code: 0 output: ".git"} | to json)
    MOCK_git_branch___show_current: ({exit_code: 0 output: "main"} | to json)
    MOCK_git_status___porcelain: ({exit_code: 0 output: ""} | to json)
    MOCK_git_log__3___oneline___no_decorate: ({exit_code: 0 output: ""} | to json)
  } {
    let result = auto-update-scratchpad

    # Should succeed
    assert ($result == true)
  }
}

# Test hybrid scratchpad preserves LLM context through extraction
export def "test hybrid scratchpad preserves LLM context" [] {
  use ../utils.nu extract-llm-context

  # Create a scratchpad with custom LLM content
  let original = "## Active Work

Lists here

## Key Learnings & Context

My custom insights
- Decision A
- Learning B"

  # Extract should preserve the custom content
  let extracted = extract-llm-context $original

  assert ($extracted | str contains "custom insights")
  assert ($extracted | str contains "Decision A")
  assert ($extracted | str contains "Learning B")
  assert (not ($extracted | str contains "[LLM:"))
}

# Test extract-llm-context extracts LLM section
export def "test extract-llm-context extracts preserved content" [] {
  use ../utils.nu extract-llm-context

  let scratchpad = "## Active Work

Some auto-generated stuff

## Key Learnings & Context

This is my important context
- Decision: Use approach X
- Learning: Y doesn't work"

  let result = extract-llm-context $scratchpad

  assert ($result | str contains "important context")
  assert ($result | str contains "Decision: Use approach X")
}

# Test extract-llm-context returns placeholder when empty
export def "test extract-llm-context returns placeholder when no context" [] {
  use ../utils.nu extract-llm-context

  let scratchpad = "## Active Work

Some stuff

## Key Learnings & Context

*[LLM: Add insights, decisions, important context for next session]*"

  let result = extract-llm-context $scratchpad

  assert ($result | str contains "[LLM:")
}

# Test extract-llm-context handles missing section
export def "test extract-llm-context handles missing section" [] {
  use ../utils.nu extract-llm-context

  let scratchpad = "## Active Work

Some stuff"

  let result = extract-llm-context $scratchpad

  assert ($result | str contains "[LLM:")
}
